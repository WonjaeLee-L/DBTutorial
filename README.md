# DBTutorial
<pre>
20240806(Day 1)
  DB: 자료를(영구적으로) 저장_그 중, 형태가 있는 정형데이터인 관계형 데이터베이스를 공부

- 관계형 데이터베이스(개발, 확장성, 자료관리가 편리)
종류로는
1) Oracle♥
2) Mysql
3) Maria♥
4) Mssql

ex) 저장할 자료: 고객의 정보(각 정보를 정의해서 저장)
      번호 이름 나이 주소 성별
       1  홍길동 37 수원  남 
       2  김길수 25 서울  여
       3  홍길동 34 대전  여

관계형 데이터베이스 용어
- 릴레이션(테이블): 전체를 말함
- 릴레이션은 행(로우, 위에서는 세줄)과 열(컬럼, 위에서는 다섯줄)로 구성됨

- 로우는 저장할 대상의 자료, CRUD로 되어있다

- 컬럼은 의미가 있음(주소는 사는곳의 의미이며 문자/ 번호라는 컬럼은 숫자고 순서)
- 컬럼은 속성, 제약조건을 지정할(가질) 수 있다(속성은 숫자 또는 문자)(제약조건, 나이의 경우 <150)

- 제약조건: not null(반드시 입력을 해야하는 컬럼값),
	   check(이 값은 정확한지 아닌지 체크하겠다)
	   unique(중복 확인)
- 사칙연산 할 수 있으면 숫자, 필요 없으면 문자로(자동차 번호는 문자, 나이는 년 지나면 숫자 달라지므로 숫자)
- 이름의 경우 무조건 말해야 합니다. 라고하면, 이름이라는 컬럼은 속성이 문자이고 제약조건은 not null
- 번호에서 1,2,3,3 <-- 무결성위배. 절대 같은게 들어가면 안된다. 다른 컬럼은(이름, 나이, 주소, 성별 등) 중복 가능하다. 번호의 경우 unique라는 제약조건을 건다.
  같은 컬럼에서 중복될 수 없음을 의미한다.
- 번호의 경우 다른것과 구분하여 하나를 특정할 수 있게 만드는 것. 이름과 나이와 주소가 같을 수 있는데 번호라는 컬럼으로는 구분할 수 있다. 
  번호라는 컬럼이 유니크하기 때문에, 로우를 유니크하게 만들 수 있다. (unique라는 제약조건으로 내가 원하는 로우를 유니크하게 만들 수 있다.)
  테이블을 만든다: 컬럼을 만든다.
  로우가 없어도 데이터가 없는 테이블일 수 있다. 컬럼만 있으면 테이블이 된다.
  
- 개념적인 모델링(생각한 것)을 실제로 만들어보기

  물리적 설계
  Create table 고객의 정보 (
  첫 번째 컬럼,
  두 번째 컬럼,
  세 번째 컬럼,
  네 번째 컬럼
  );
  
  컬럼 속성 제약조건,
  
  Create table 고객의 정보 (
  번호 number unique key,
  이름 varchar2(6) not null,
  나이 number(2) default 1,
  주소 varchar2(50)
  );
  
  number: oracle의 자료형 type
  이름 varchar2(byte)

  default 1 : 처음부터 1이라는 값으로 시작
  number(3,1) : 0~99까지. 뒤에1은 소숫점한자리를 의미
  desc : 현재 만들어진 테이블의 구조를 확인하는 명령어
  create table : table을 만드는 명령어
  alter table : table 수정 명령어
  insert into aaa value (1, ‘’);
  -> aaa table의 value를 저장하겠다(로우를 집어넣는 명령어)
  select * from aaa;
  -> aaa라는 릴레이션에 모든(*)걸 보여달라

  // 관계형 데이터베이스 용어를 중심으로 공부한다.  
  
  
    
  20240807(Day 2)
  키 : 컬럼에 부여하는 기능(기본키/외래키)
    
    1.
  기본키: (유일성을 가진다. 인덱스를 형성한다.)
  튜플(row)을 유일하게 식별할 수 있다.
  -> 그래야 갱신, 삭제 이상현상을 방지할 수 있다.
    
  기본키로 index(색인)을 형성하여 검색속도를 향상시켜 저장한다. 
  index: 검색속도를 향상시킨다. 색인을 만들어 놓으면 검색속도가 빨라진다.
  서랍장에 옷을 구분해서 넣어놓는 생각 자체가 색인과 같은 개념이라 생각
   기본키는 null 불가하다.(not null을 포함하고 있다)
  
  index는 테이블당 한 개라고 생각. 많아지면 속도가 더 느릴 수 있다.
  
  
  
  기본키로 설정하는 코드
  create table m(
  ID varchar2(1) primary key,
  name  varchar2(2),
  ad varchar2(10)
  );
  
  primary key 자리에 원래 unique를 넣었었음.
  대신 primary key를 넣어서 유일하게 식별하게 만들면서 검색속도도 빨라진다. (자동으로 ID를 가지고 색인을 만드는 것)
  ID로 검색했을때만 속도가 빨라지는 특성을 가진다.
  
  member
  이름	주소	전화번호
  홍길동	서울	1111
  일지매	서울	1111
  홍길동	수원	2222
  
  C; row insert
   -> 상관 x
  R: row select
   -> 상관 x
  U: row update
   -> 홍길동의 전화번호를 4444로 바꾸세요/ 누군지 확실하지 않음
   (갱신 이상현상이 발생할 수 있다.)
  	(이유 : row(튜플)를 유일하게 식별하지 못한다. row가 unique하지 않다.
  		 -> 이상 현상이 발생할 수 있다.)
  D: row delete
   -> 홍길동을 삭제하세요/ 누군지 확실하지 않음
   (삭제 이상현상이 발생할 수 있다.)
  	(이유 : row(튜플)를 유일하게 식별하지 못한다. row가 unique하지 않다.
  		 -> 이상 현상이 발생할 수 있다.)
  
  -> 이상현상 해결을 위해서
  ID라는 컬럼을 새로 만든다. ID를 unique하게 설정한다.
  
  -> READ시의 속도를 고려해야함. 속도를 빠르게. 속도는 unique로 해결이 불가능.
  속도는 index로 해결.
  
    2.
  외래키: 컬럼 to 컬럼
  
  설계시 고려: 1. 이상현상 |-> 유일성 보장해서 해결
  			                  |-> 데이터의 중복을 최소화(정규화를 진행한다 = 테이블 분리)
  			                    	외래키로 해결
  
  ex)
  자동차 등록. 한 사람이 여러대를 등록
  여러대를 등록하려보니까 테이블 하나로 불가능해짐
  (게시판에 글을 작성한다. 게시글 테이블과 댓글 테이블)
  
  ID	이름	전번	차번호
  a	  홍길동	1111	  1
  a	  홍	  1111	  2
  -> 차번호 제외하고는 다 중복 -> UD에서 이상현상 발생
  -> unique 한다고 해결되지 않음.
  -> 테이블 분리하기(= 정규화를 거친다)
  
  table member(부모 릴레이션)
  (PK)
  ID	이름	전번
  a	홍	1111
  b	홍	2222
  
  table car(자식 릴레이션)
  차번호	ID(외래키)--> 외래키가 member 테이블의 ID를 참조함
  1	a
  2	a
  
  외래키는 car table이 소유하고있음. 외래키 설정은 car table에서 한다.
  자식릴레이션의 외래키는 부모 릴레이션의 특정 컬럼(참조대상)을 참조한다.
  참조대상은 유일성을 갖춰야하고, 자식릴레이션의 외래키는 유일성 없어도 된다.
  
  // 기본키와 외래키의 개념을 이해하고 활용한다. 관계형 데이터베이스 용어에 대해 더 익숙해진다.

  
  20240808(Day 3)
  개념적 설계 -> 논리적 설계(테이블 명세서) -> 물리적 설계(쿼리문)
  (시나리오1)
  - 고객관리
  고객은 아이디와 이름, 성별, 포인트로 구성된다.
  아이디는 8글자이며, 중복된 아이디는 사용할 수 없다.
  이름은 한글로 최대 5글자이며 성별은 남과 여로 저장한다.
  포인트는 최대 9999.99까지 저장할 수 있다.
  
  고객은 출석도장을 찍을 수 있다.
  출석도장은 날짜를 저장한다.
  고객은 하루에 여러번 출석도장을 찍을 수 있다. 
  
  고객 table, 출석대장 table 로 나누는 이유에 대한 공부 => ERD 기법
  
  ERD  -> 개념적 설계
  e: 개체 – 독립적으로 존재할 수 있는 대상
 	위의 시나리오에서 고객이 개체 (id, name 등이 속성). 출석은 고객이 하는거니까 독립적이 아님. 출석대장이 개체(시간이 속성).
  그럼 두 개체가 관계가 있는지 본다. -> 고객 개체와 출석시간 개체는 출석관계가 있고 1:n 관계를 갖는다. 고객은 무조건 출석해야함
  
  
20240902(Day)
1. 테이블 관리 : create table, drop table, alter table
	      : 테이블(릴레이션), 속성(속성타입, 제약조건)
	      : 타입 - int, number*, varchar2, timestamp
	      : 제약조건 - 유일성(기본키, unique), not null, check, default
	      : 키 - 기본키 : 유일성, not null, 인덱스 형성(검색속도 향상 - where절에서 사용)
						
		 외래키 : 컬럼 투 컬럼, 자식 릴레이션 컬럼이 부모 릴레이션의 컬럼을 참조한다.
			외래키 제약 조건 : cascade, set null
	      : ERD - 개체와 개체의 관계분석 1:1, 1:N, N:M 분석 후 테이블 형성


2. 테이블에 저장된 튜플의 조작
	삽입 - insert
	갱신 - update : 특정 튜플을 선택하여 갱신하려면 where절 사용
	삭제 - delete : 특정 튜플을 선택하여 삭제하려면 where절 사용
	검색 - select : 각 절의 의미 암기, 절의 실행 순서 이해

    *  실행 순서  /  절의 의미
	4	select 절 : 컬럼 선택
	1	from 절 : 대상 테이블
	2	where 절 : 대상 테이블로부터 튜플을 선정할 조건
	3	group by 절 : 그룹화
	5	order by 절 : 출력할때 정렬

3. 함수 : 함수를 호출하고 함수의 기능을 실행하고 결과값을 리턴,
	결과값을 리턴받아서 처리한다. 예를 들어 count(*) 함수를 호출하면
	튜플의 수를 카운팅하여 카운팅 결과값을 리턴한다.


20240903(Day)
------------------------------oracle 함수 정리------------------------------
1. 집계 함수
    max() : 최대값
    min() : 최소값
    avg() : 평균값
    sum() : 합계
    mod(a,b) : a를 b로 나눈 나머지
    count(*) : 총 레코드 세는 함수, null 포함
    count(컬럼명) : 컬럼명 기준으로 총 레코드 수 세는 함수, null 제외
    
2. 문자열 함수
    lower('HH') : hh, 해당 컬럼의 값을 소문자로 변환하는 함수
    upper('hh') : HH, 해당 컬럼의 값을 대문자로 변환하는 함수
    inicap('go go go') : Go Go Go, 첫글자, 공백 이후 첫글자를 대문자로 변환
    concat(a,b) : ab, 두 개의 문자열을 연결
    substr('HelloWorld',1,5) : Hello, 문자열의 1번째자리부터 5번째자리까지 추출
    length('oracle') : 6, 문자열의 길이
    instr('HelloWorld','W') : 6, 문자열에서 특정 문자의 위치를 세는 함수.
                                 없다면 0 반환
    lpad('SQLPLUS',10,'*') : ***SQLPLUS, 해당 길이에 부족한 부분을 왼쪽부터 채움
    rpad('SQLPLUS',10,'*') : SQLPLUS***, 해당 길이에 부족한 부분을 오른쪽부터 채움
    trim('SQ LP L US') : SQLPLUS, 공백 제거
    ltrim('*SQLPLUS','*') : SQLPLUS, 좌측부터 문자열에서 해당 문자를 제거
    rtrim('SQLPLUS*','*') : SQLPLUS, 우측부터 문자열에서 해당 문자를 제거
    replace('SEVLTL','L','EN') : SEVENTEN, 해당 문자를 다른 문자로 바꾸어줌
    nvl(expr1,expr2) : expr1이 null이면 expr2 값으로 반환하는 함수
    nvl2(expr1,expr2,expr3) : expr1과 null1을 비교해 null이 아니면 expr2,
                              null이면 expr3을 반환하는 함수
    nullif(expr1,expr2) : expr1과 expr2를 비교하여 같으면 null, 다르면 expr1 반환
    coalesce(expr1,expr2,...exprn) : 목록에서 첫번째로 null아닌 expr을 반환
    || : 결합연산자 ex) select uname || '의 평균은 ' || aver || '입니다' 
    
3. 숫자 함수
    abs(-7) : 7, 절대값을 계산하는 함수
    mod(1500, 200) : 100, 1500 / 200 의 나머지를 반환하는 함수
    ceil(1.123) ; 2 :       소수점 첫째자리에서 해당 값을 올림 처리한 정수를 반환하고
    ceil(-1.623) ; -1 :     해당 값보다는 크지만 가장 근접하는 최소값을 구하는 함수
    
    floor(1.123)  :         소수점 첫째자리에서 해당 값을 내림 처리한 정수를 반환하고 
    floor(-1.123) :         해당 값보다는 작지만 가장 근접하는 최대값을 구하는 함수
    round(n,m) : 해당 숫자 n에서 m자리까지 반올림하는 함수
    trunc(n.m) : 해당 숫자 n에서 m자리까지 버림하는 함수
    to_number : 문자열을 숫자형으로 바꿔준다.
                      
4. 날짜 함수
    sysdate : 현재 날짜, 시간 ex) select sysdate from dual;
    extract(year from sysdate) : sysdate에서 년월일 추출(year,month,day)
    months_between(sysdate, to_date('2014-12-11')) : 첫번째 날짜에서
                                        두번째 날짜 사이 개월 수를 반환하는 함수
    to_date() : 문자열을 날짜형으로 변환
    add_months(sysdate, 5) : 해당 날짜에서 개월 수를 더한 날짜를 반환
    next_day(sysdate, '금요일') : 해당 날짜에서 최초로 도래하는 해당 요일의 날짜를 반환
    last_day(sysdate) : 해당 날짜가 포함되어 있는 달의 마지막 날짜를 반환
5. 형변환 함수
    to_char(원래 날짜,'원하는 모양') - 숫자와 날짜를 문자로 변환해준다
    to_number('1')
    to_date('문자','날짜포맷')
    
6. if문 역할 함수
    decode : decode(컬럼,조건1,결과1,조건2,결과2)
    case(case when then else end) :
        case
              when 조건1 then 조건1이 참일 경우 실행
              when 조건2 then 조건2가 참일 경우 실행
              else 조건1과 조건2 어느 것도 참이 아닌 경우 실행
        end
-------------------------------------------------------------------------------------
</pre>
